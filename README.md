# GenePy

GenePy is a Python port of miniEugene, a specification tool for exploring genetic designs based on user declared rules, which act as constraints for potential sequences. GenePy currently handles strings to represent abstract parts. For more information on miniEugene click [here](http://minieugene.cidarlab.org/index.html). To learn more about the Eugene ecosystem click [here](http://eugenecad.org/index.html).

## Installing

Clone this repo or download the files. For example:
```bash
git clone https://github.com/hkim42/GenePy.git
```
will clone the repo.

## Setup
If not already setup, please install the latest version of Python3.

### Windows
A Windows Installer is available here [link](https://www.python.org/downloads/)

### macOS
```bash
$ brew install python3
```

GenePy requires following packages:
* `python-constraint`
* `tkinter`

`tkinter` is often already installed on many Python running machines but visit this [link](https://docs.python.org/3/library/tkinter.html) for more information regarding installing and setting up `tkinter`

`python-constraint` can be installed using `pip3`.

```bash
$ pip3 install python-constraint
```

## Constraint Solving Problem (CSP)
GenePy uses declared rules to generate solution sequences by modeling as a CSP. Each position in the sequence is considered a variable and counting rules are used to determine the domain of parts for each variable. GenePy then converts Eugene constraints to boolean functions that are used as constraints for the CSP. Currently GenePy leverages `python-constraint` to solve CSP's. From `python-constraint`, GenePy uses backtracking depth-first and minimum-conflict algorithms as solvers. Backtracking enables GenePy to generate exhaustive list of sequences while minimum-conflict enables quick generation of a single sequence. Further optimization in this area should improve GenePy efficiency. Visit [python-constraint](https://labix.org/python-constraint) for more information regarding this package.

## Usage

GenePy can used by importing the class and declaring rules in a Python script or the `tkinter` based GUI. The following describes how users can interact with both modes.

## GenePy Class
Following methods enable users to interact with GenePy to declare rules and generate relevant files. GenePy currently only accepts string representation of parts. Counting rules are used to generate variable domains and positioning rules are used to place parts. Orientation and interaction rules are currently only captured and stored in data structures and do not play a role in determining constraining sequences.
### Counting Rules
* `contains(a)`
* `morethan(a,n)`
* `exactly(a,n)`
* `then(a,B)`
* `witH(a,B)`

### Positioning Rules
* `startswith(a)`
* `endswith(a)`
* `all_after(a, B)`
* `some_after(a,B)`
* `all_before(a,B)`
* `some_before(a,B)`
* `all_nextto(a,B)`
* `some_nextto(a,B)`

### Orientation Rules
* `all_forward_if(a)`
* `all_reverse_if(a)`
* `some_forward(a)`
* `some_reverse(a)`
* `all_forward()`
* `all_reverse()`

### Interaction Rules
* `represses(a,B)`
* `induces(a,B)`
* `drives(a,B)`

### General
* `generate(number=0)`
* `change_length(n)`
  * Must call `change_length()` before `generate()` in script
* `rulesToFile(filename)`
* `solutionsToFile(filename, number=0)`

### Rules
All rules are captured and mapped to a nested dictionary. They can be accessed internally through a class variable called `rules` or externally by writing them to a JSON file via `rulesToFile`.  This enables easy access for referencing rules within GenePy and in custom software workflows. Rule files are stored in a `Rules` directory.

### Solution Sequences
Sequences are generated by `generate()` as a list of dictionaries, with each dictionary representing a sequence. All generated sequences are stored in a class variable called `solutions`. They can be accessed internally by `genepy` object or externally by outputting to a JSON file through `solutionsToFile(filename)`. Solution files are stored within a `Solutions` directory.
## Example

```python
from genepy import genepy

if __name__ == '__main__':
    # initiate class
    gp = genepy(10)

    # add user defined rules with rule methods
    gp.contains("p1")
    gp.contains("p2")
    gp.contains("p3")
    gp.exactly("p4", 2)
    gp.morethan("p5", 1)

    gp.some_before("p2", "p3")
    gp.endswith("p5")
    gp.startswith("p1")

    gp.induces("p1", "p3")
    gp.drives("p3", "p2")

    # print out generated solutions that satisfy rules
    print(gp.rules["induces"])
    outputs = gp.generate(5)

    for x in outputs:
        print(x)

    gp.solutionsToFile("test_solutions.json", 5)
    gp.rulesToFile("test_rules.json")
```
### Expected Output
```
{'p1': 'p3'}
{0: 'p1', 1: 'p4', 2: 'p4', 3: 'p3', 4: 'p3', 5: 'p3', 6: 'p2', 7: 'p3', 8: 'p5', 9: 'p5'}
{0: 'p1', 1: 'p4', 2: 'p4', 3: 'p3', 4: 'p3', 5: 'p3', 6: 'p2', 7: 'p5', 8: 'p3', 9: 'p5'}
{0: 'p1', 1: 'p4', 2: 'p4', 3: 'p3', 4: 'p3', 5: 'p3', 6: 'p5', 7: 'p2', 8: 'p3', 9: 'p5'}
{0: 'p1', 1: 'p4', 2: 'p4', 3: 'p3', 4: 'p3', 5: 'p2', 6: 'p3', 7: 'p3', 8: 'p5', 9: 'p5'}
{0: 'p1', 1: 'p4', 2: 'p4', 3: 'p3', 4: 'p3', 5: 'p2', 6: 'p3', 7: 'p2', 8: 'p5', 9: 'p5'}
```

## GenePy GUI

### GUI Directions

1. Run the `test_gui.py` script to start the GUI.

2. The main window will pop up with various widgets for user inputs.
  * It is recommended to open the console window first because it displays all the rules that are defined by the user along with the output DNA sequences.

3. Clicking the buttons for adding rules will open another window where the user can enter the parameters pertaining to the rule. There is a button for each of the rules.

4. Lastly, running the solver will display all possible DNA sequences on the console window. If there are no possible sequences nothing will be added on the console window.

  * There are spaces for defining the number of parts to be used and the number of solutions the user desires. When the button for running the solver is pressed, these values will be passed into the code backend.

### Example
``` python
import tkinter as tk
from genepy import genepy
from genepy_gui import genepy_gui

if __name__ == '__main__':
    foo = genepy_gui()
```

## Acknowledgements

Thanks to Dr. Ernst Oberotner, Radhakrishna Sanka, and Professor Douglas Densmore, PhD.

No thanks Corona
